<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test April 30, 2025</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Test April 30, 2025</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="500"></canvas>

        <div class="controls">
            <button id="newGameBtn">New Game</button>
            <button id="resetBtn">Reset</button>
            <input type="date" id="dateInput" value="2025-04-30">
            <button id="loadDateBtn">Load Date</button>
        </div>

        <div class="info">
            <p id="dateDisplay"></p>
            <p id="scoreDisplay">Moves: 0</p>
            <p id="minMovesDisplay">Minimum Moves: 0</p>
            <p id="solvableStatus"></p>
        </div>
    </div>

    <script src="constants.js"></script>
    <script src="utils.js"></script>
    <script src="seededRandom.js"></script>
    <script src="mapCreator.js"></script>
    <script src="player.js"></script>
    <script src="animation.js"></script>
    <script src="renderer.js"></script>
    <script src="inputHandler.js"></script>
    <script src="gameManager.js"></script>
    <script>
        // Initialize the game when the page loads
        window.onload = function() {
            const game = new GameManager();

            // Set the date to April 30, 2025
            game.generateMapFromDate("2025-04-30");

            // Start the game loop
            game.startGameLoop();

            // Add debug logging
            console.log("Game initialized with date: 2025-04-30");
            console.log("Seed:", game.currentSeed);
            console.log("Player position:", game.player.initialPos);
            console.log("Target position:", game.grid.targetPos);
            console.log("Minimum moves:", document.getElementById('minMovesDisplay').textContent);

            // Add a button to test the BFS algorithm
            const testBfsBtn = document.createElement('button');
            testBfsBtn.textContent = 'Test BFS Algorithm';
            testBfsBtn.style.marginTop = '20px';
            document.body.appendChild(testBfsBtn);

            // Add a button to find the shortest path manually
            const findShortestPathBtn = document.createElement('button');
            findShortestPathBtn.textContent = 'Find Shortest Path Manually';
            findShortestPathBtn.style.marginTop = '20px';
            findShortestPathBtn.style.marginLeft = '10px';
            document.body.appendChild(findShortestPathBtn);

            // Add a button to simulate playing the game
            const simulateGameBtn = document.createElement('button');
            simulateGameBtn.textContent = 'Simulate Game';
            simulateGameBtn.style.marginTop = '20px';
            simulateGameBtn.style.marginLeft = '10px';
            document.body.appendChild(simulateGameBtn);

            // Add a div to display results
            const resultsDiv = document.createElement('div');
            resultsDiv.style.marginTop = '20px';
            resultsDiv.style.padding = '10px';
            resultsDiv.style.border = '1px solid #ccc';
            resultsDiv.style.backgroundColor = '#f9f9f9';
            document.body.appendChild(resultsDiv);

            testBfsBtn.addEventListener('click', function() {
                console.log("Testing BFS algorithm...");
                resultsDiv.innerHTML = '<h3>BFS Algorithm Results</h3>';

                // Get the current grid state
                const grid = game.grid.grid;
                console.log("Grid state:", JSON.stringify(grid));

                // Log player and target positions
                console.log("Player position:", game.player.initialPos);
                console.log("Target position:", game.grid.targetPos);
                resultsDiv.innerHTML += `<p>Player position: (${game.player.initialPos.x}, ${game.player.initialPos.y})</p>`;
                resultsDiv.innerHTML += `<p>Target position: (${game.grid.targetPos.x}, ${game.grid.targetPos.y})</p>`;

                // Run the BFS algorithm
                const result = game.grid.checkSolvable(game.player.initialPos, false);
                console.log("BFS result:", result);
                resultsDiv.innerHTML += `<p>BFS result: ${JSON.stringify(result)}</p>`;
            });

            findShortestPathBtn.addEventListener('click', function() {
                console.log("Finding shortest path manually...");
                resultsDiv.innerHTML = '<h3>Manual Path Finding Results</h3>';

                // Calculate possible paths manually
                console.log("Calculating possible paths manually...");
                resultsDiv.innerHTML += '<p>Calculating possible paths manually...</p>';

                // Try all four directions
                const directions = ['UP', 'RIGHT', 'DOWN', 'LEFT'];
                let shortestPath = null;
                let shortestPathLength = Infinity;

                for (let i = 0; i < 4; i++) {
                    const path = game.player.calculateMovePath(i);
                    console.log(`Direction ${directions[i]} (${i}):`, path);
                    resultsDiv.innerHTML += `<p>Direction ${directions[i]} (${i}): ${path.length} steps</p>`;

                    // Check if this path reaches the target
                    const lastPos = path[path.length - 1];
                    if (lastPos.x === game.grid.targetPos.x && lastPos.y === game.grid.targetPos.y) {
                        console.log(`Target can be reached in 1 move by going ${directions[i]}`);
                        resultsDiv.innerHTML += `<p><strong>Target can be reached in 1 move by going ${directions[i]}</strong></p>`;

                        // Check if this is the shortest path
                        if (path.length < shortestPathLength) {
                            shortestPath = path;
                            shortestPathLength = path.length;
                        }
                    }
                }

                if (shortestPath) {
                    console.log("Shortest path:", shortestPath);
                    resultsDiv.innerHTML += `<p>Shortest path length: ${shortestPathLength}</p>`;
                    resultsDiv.innerHTML += `<p>This means the puzzle can be solved in 1 move.</p>`;
                } else {
                    console.log("No direct path to target found.");
                    resultsDiv.innerHTML += `<p>No direct path to target found.</p>`;

                    // Try two moves
                    resultsDiv.innerHTML += `<p>Trying two moves...</p>`;

                    // For each possible first move
                    for (let i = 0; i < 4; i++) {
                        const firstPath = game.player.calculateMovePath(i);
                        const firstEndPos = firstPath[firstPath.length - 1];

                        // Skip if the first move ends at the target
                        if (firstEndPos.x === game.grid.targetPos.x && firstEndPos.y === game.grid.targetPos.y) {
                            continue;
                        }

                        // Temporarily move the player to the end of the first path
                        const originalPos = { ...game.player.pos };
                        game.player.pos.x = firstEndPos.x;
                        game.player.pos.y = firstEndPos.y;

                        // Try all four directions for the second move
                        for (let j = 0; j < 4; j++) {
                            const secondPath = game.player.calculateMovePath(j);
                            const secondEndPos = secondPath[secondPath.length - 1];

                            // Check if the second move reaches the target
                            if (secondEndPos.x === game.grid.targetPos.x && secondEndPos.y === game.grid.targetPos.y) {
                                console.log(`Target can be reached in 2 moves: ${directions[i]} then ${directions[j]}`);
                                resultsDiv.innerHTML += `<p><strong>Target can be reached in 2 moves: ${directions[i]} then ${directions[j]}</strong></p>`;

                                // Calculate total path length
                                const totalPathLength = firstPath.length + secondPath.length - 1; // -1 because the first position of secondPath is counted twice

                                // Check if this is the shortest path
                                if (totalPathLength < shortestPathLength) {
                                    shortestPath = [...firstPath, ...secondPath.slice(1)];
                                    shortestPathLength = totalPathLength;
                                }
                            }
                        }

                        // Restore the player's position
                        game.player.pos.x = originalPos.x;
                        game.player.pos.y = originalPos.y;
                    }

                    if (shortestPath) {
                        console.log("Shortest path (two moves):", shortestPath);
                        resultsDiv.innerHTML += `<p>Shortest path length: ${shortestPathLength}</p>`;
                        resultsDiv.innerHTML += `<p>This means the puzzle can be solved in 2 moves.</p>`;
                    } else {
                        console.log("No path to target found with two moves.");
                        resultsDiv.innerHTML += `<p>No path to target found with two moves.</p>`;

                        // Try three moves (this could get complex, so we'll just indicate it's possible)
                        resultsDiv.innerHTML += `<p>Trying three moves...</p>`;
                        resultsDiv.innerHTML += `<p>This would require a more complex simulation.</p>`;
                    }
                }

                // Compare with BFS result
                const bfsResult = game.grid.checkSolvable(game.player.initialPos, true);
                resultsDiv.innerHTML += `<p>BFS algorithm says minimum moves: ${bfsResult.minMoves}</p>`;

                if (shortestPath && bfsResult.minMoves !== Math.ceil(shortestPathLength / 2)) {
                    resultsDiv.innerHTML += `<p><strong>DISCREPANCY DETECTED: Manual calculation says ${Math.ceil(shortestPathLength / 2)} moves, BFS says ${bfsResult.minMoves} moves.</strong></p>`;
                }
            });

            simulateGameBtn.addEventListener('click', function() {
                console.log("Simulating game...");
                resultsDiv.innerHTML = '<h3>Game Simulation Results</h3>';

                // Reset the player
                game.resetPlayer();

                // Try to solve the puzzle with the minimum number of moves
                const bfsResult = game.grid.checkSolvable(game.player.initialPos, true);
                resultsDiv.innerHTML += `<p>BFS algorithm says minimum moves: ${bfsResult.minMoves}</p>`;

                // Try all possible combinations of moves up to the minimum number of moves
                let solved = false;
                const directions = ['UP', 'RIGHT', 'DOWN', 'LEFT'];

                // Try one move
                for (let i = 0; i < 4; i++) {
                    // Reset the player
                    game.resetPlayer();

                    // Make the move
                    game.movePlayer(i);

                    // Check if the puzzle is solved
                    if (Utils.arePositionsEqual(game.player.pos, game.grid.targetPos)) {
                        console.log(`Puzzle solved in 1 move: ${directions[i]}`);
                        resultsDiv.innerHTML += `<p><strong>Puzzle solved in 1 move: ${directions[i]}</strong></p>`;
                        solved = true;
                        break;
                    }
                }

                if (!solved) {
                    // Try two moves
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            // Reset the player
                            game.resetPlayer();

                            // Make the first move
                            game.movePlayer(i);

                            // Make the second move
                            game.movePlayer(j);

                            // Check if the puzzle is solved
                            if (Utils.arePositionsEqual(game.player.pos, game.grid.targetPos)) {
                                console.log(`Puzzle solved in 2 moves: ${directions[i]} then ${directions[j]}`);
                                resultsDiv.innerHTML += `<p><strong>Puzzle solved in 2 moves: ${directions[i]} then ${directions[j]}</strong></p>`;
                                solved = true;
                                break;
                            }
                        }
                        if (solved) break;
                    }
                }

                if (!solved) {
                    // Try three moves
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            for (let k = 0; k < 4; k++) {
                                // Reset the player
                                game.resetPlayer();

                                // Make the first move
                                game.movePlayer(i);

                                // Make the second move
                                game.movePlayer(j);

                                // Make the third move
                                game.movePlayer(k);

                                // Check if the puzzle is solved
                                if (Utils.arePositionsEqual(game.player.pos, game.grid.targetPos)) {
                                    console.log(`Puzzle solved in 3 moves: ${directions[i]} then ${directions[j]} then ${directions[k]}`);
                                    resultsDiv.innerHTML += `<p><strong>Puzzle solved in 3 moves: ${directions[i]} then ${directions[j]} then ${directions[k]}</strong></p>`;
                                    solved = true;
                                    break;
                                }
                            }
                            if (solved) break;
                        }
                        if (solved) break;
                    }
                }

                if (!solved) {
                    console.log("Could not solve the puzzle in 3 moves.");
                    resultsDiv.innerHTML += `<p>Could not solve the puzzle in 3 moves.</p>`;
                }

                // Compare with BFS result
                if (solved) {
                    const actualMoves = game.player.moveCount;
                    resultsDiv.innerHTML += `<p>Actual moves: ${actualMoves}</p>`;

                    if (actualMoves !== bfsResult.minMoves) {
                        resultsDiv.innerHTML += `<p><strong>DISCREPANCY DETECTED: Actual moves ${actualMoves}, BFS says ${bfsResult.minMoves} moves.</strong></p>`;
                    }
                }
            });
        };
    </script>
</body>
</html>
